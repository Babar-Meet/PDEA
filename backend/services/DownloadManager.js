const { spawn, exec, execSync } = require('child_process');
const path = require('path');
const fs = require('fs');
const { v4: uuidv4 } = require('uuid');

class DownloadManager {
  constructor() {
    this.downloads = new Map();
    this.processes = new Map();
    this.wsClients = new Set();
  }

  registerWSClient(ws) {
    this.wsClients.add(ws);
    ws.on('close', () => {
      this.wsClients.delete(ws);
    });
  }

  broadcastProgress(downloadId, progressData) {
    const message = JSON.stringify({
      type: 'progress',
      downloadId,
      ...progressData
    });

    this.wsClients.forEach(client => {
      if (client.readyState === 1) {
        client.send(message);
      }
    });
  }

  registerDownload(downloadId, metadata) {
    this.downloads.set(downloadId, {
      id: downloadId,
      status: 'starting',
      progress: 0,
      speed: '0',
      eta: '0',
      ...metadata,
      timestamp: new Date().toISOString()
    });
    this.broadcastProgress(downloadId, this.downloads.get(downloadId));
  }

  registerProcess(downloadId, childProcess, filePath) {
    this.processes.set(downloadId, {
      process: childProcess,
      filePath,
      cancelled: false,
      killed: false
    });
  }

  updateProgress(downloadId, updates) {
    const download = this.downloads.get(downloadId);
    if (!download) return;

    // Don't update progress if download was cancelled
    const processData = this.processes.get(downloadId);
    if (processData && processData.cancelled) {
      return;
    }

    Object.assign(download, updates);
    this.downloads.set(downloadId, download);
    this.broadcastProgress(downloadId, download);
  }

  getDownload(downloadId) {
    return this.downloads.get(downloadId);
  }

  getAllDownloads() {
    return Array.from(this.downloads.values()).sort(
      (a, b) => new Date(b.timestamp) - new Date(a.timestamp)
    );
  }

  /**
   * Forcefully kill a process by PID and also kill any yt-dlp processes
   */
  forceKillProcess(pid) {
    const isWindows = process.platform === 'win32';
    
    if (isWindows) {
      try {
        execSync(`taskkill /PID ${pid} /T /F`, { stdio: 'ignore' });
      } catch (e) {
        try {
          execSync(`taskkill /F /PID ${pid}`, { stdio: 'ignore' });
        } catch (e2) {
          // Ignore
        }
      }
      try {
        execSync(`taskkill /F /IM yt-dlp.exe`, { stdio: 'ignore' });
      } catch (e) {
        // No yt-dlp processes
      }
    } else {
      try {
        process.kill(-pid, 'SIGKILL');
      } catch (e) {
        // Ignore
      }
      try {
        process.kill(pid, 'SIGKILL');
      } catch (e) {
        // Ignore
      }
      try {
        execSync(`pkill -9 yt-dlp`, { stdio: 'ignore' });
      } catch (e) {
        // No yt-dlp processes
      }
    }
  }

  async cancelDownload(downloadId) {
    const processData = this.processes.get(downloadId);
    if (!processData) {
      // Check if download exists but no process running
      const download = this.downloads.get(downloadId);
      if (download) {
        this.updateProgress(downloadId, {
          status: 'cancelled',
          error: 'Download cancelled by user'
        });
      }
      return false;
    }

    // Immediately mark as cancelled to prevent any further progress updates
    processData.cancelled = true;
    
    const { process, filePath } = processData;
    const pid = process.pid;
    
    // Immediately remove from processes map so close handler knows it's cancelled
    this.processes.delete(downloadId);

    // Forcefully kill the process
    if (pid) {
      this.forceKillProcess(pid);
    } else {
      try {
        process.kill('SIGKILL');
      } catch (e) {
        // Ignore
      }
    }

    // Also kill any yt-dlp processes by name
    try {
      if (process.platform === 'win32') {
        execSync(`taskkill /F /IM yt-dlp.exe 2>nul`, { stdio: 'ignore' });
      } else {
        execSync(`pkill -9 yt-dlp 2>/dev/null`, { stdio: 'ignore' });
      }
    } catch (e) {
      // Ignore errors
    }

    // Update status immediately to 'cancelled'
    this.updateProgress(downloadId, {
      status: 'cancelled',
      error: 'Download cancelled by user',
      progress: 0,
      speed: '0',
      eta: '0'
    });

    // Clean up all temporary files including thumbnails
    this.cleanupAllTempFiles(filePath, true);

    console.log(`Download cancelled: ${downloadId}`);
    return true;
  }

  removeDownload(downloadId) {
    // Remove from downloads map
    this.downloads.delete(downloadId);
    
    // Remove from processes map if exists
    this.processes.delete(downloadId);
    
    // Broadcast removal to all clients
    this.broadcastProgress(downloadId, { type: 'removed' });
    
    console.log(`Download removed: ${downloadId}`);
    return true;
  }

  /**
   * Clean up all temporary files generated by yt-dlp
   * including .part, .temp, .tmp, .ytdl, fragment files, thumbnails, etc.
   */
  cleanupAllTempFiles(basePath, includeThumbnail = false) {
    if (!basePath) return;

    const dir = path.dirname(basePath);
    const basename = path.basename(basePath, path.extname(basePath));
    
    // Get the video title from download record if available
    const downloadId = Array.from(this.downloads.entries())
      .find(([id, d]) => d.status === 'cancelled' && d.saveDir && basePath.includes(d.saveDir))?.[0];
    const download = downloadId ? this.downloads.get(downloadId) : null;
    const videoTitle = download?.title || basename;

    // Patterns of files to delete
    const patterns = [
      /\.part$/,           // Partial download files
      /\.temp$/,           // Temporary files
      /\.tmp$/,            // TMP files
      /\.ytdl$/,           // yt-dlp temp files
      /\.ffmpeg$/,         // FFmpeg temp files
      /\.part\.frag-\d+$/, // Fragmented download parts
      /\.webm\.frag-\d+$/, // WebM fragments
      /\.mp4\.frag-\d+$/,  // MP4 fragments
      /\.mkv\.frag-\d+$/,  // MKV fragments
      /\.m4a\.frag-\d+$/,  // M4A audio fragments
      /\.mp3\.frag-\d+$/,  // MP3 fragments
      /\.download$/,        // Download in progress
      /\.crdownload$/,     // Chrome temp download
    ];

    let cleanedCount = 0;

    try {
      if (fs.existsSync(dir)) {
        const files = fs.readdirSync(dir);
        
        files.forEach(file => {
          const shouldDelete = patterns.some(pattern => pattern.test(file)) ||
                               // Also delete files with the same basename and temp extensions
                               (file.includes(basename) && (
                                 file.endsWith('.part') ||
                                 file.endsWith('.temp') ||
                                 file.endsWith('.tmp') ||
                                 file.endsWith('.ytdl') ||
                                 file.endsWith('.ffmpeg') ||
                                 /\.f\d+$/.test(file) ||
                                 /\.frag-\d+$/.test(file)
                               ));
          
          if (shouldDelete) {
            const fullPath = path.join(dir, file);
            try {
              fs.unlinkSync(fullPath);
              cleanedCount++;
            } catch (e) {
              // File might be locked or already deleted
            }
          }
        });
      }
    } catch (err) {
      // Directory might not exist
    }

    // Also clean up thumbnail if requested (yt-dlp saves thumbnails in same dir)
    if (includeThumbnail && videoTitle) {
      const thumbnailExtensions = ['.jpg', '.webp', '.png', '.gif', '.jpeg', '.thumb'];
      
      try {
        if (fs.existsSync(dir)) {
          const files = fs.readdirSync(dir);
          files.forEach(file => {
            const ext = path.extname(file).toLowerCase();
            if (thumbnailExtensions.includes(ext)) {
              // Check if this thumbnail matches our video title
              // Try multiple matching strategies
              const fileWithoutExt = file.replace(/\.[^/.]+$/, '');
              
              // Strategy 1: Exact match with video title
              // Strategy 2: Video title is contained in filename
              // Strategy 3: Filename contains significant parts of video title
              
              const videoTitleLower = videoTitle.toLowerCase();
              const fileLower = fileWithoutExt.toLowerCase();
              
              // Check if video title is in the filename (flexible matching)
              const isMatch = 
                fileLower === videoTitleLower ||
                fileLower.includes(videoTitleLower) ||
                videoTitleLower.includes(fileLower) ||
                // Check for partial matches with key words
                (videoTitleLower.split(' ').filter(w => w.length > 3).some(word => 
                  fileLower.includes(word)
                ));
              
              if (isMatch) {
                const fullPath = path.join(dir, file);
                try {
                  fs.unlinkSync(fullPath);
                  cleanedCount++;
                  console.log(`Deleted thumbnail: ${file}`);
                } catch (e) {
                  // Ignore
                }
              }
            }
          });
        }
      } catch (err) {
        // Ignore
      }
    }
    
    if (cleanedCount > 0) {
      console.log(`Cleaned up ${cleanedCount} files in ${dir}`);
    }
  }

  /**
   * Clean up all temporary files in the public directory
   */
  cleanupAllTempFilesInPublicDir() {
    const publicDir = path.join(__dirname, '../public');
    
    const tempExtensions = ['.part', '.temp', '.tmp', '.ytdl', '.ffmpeg', '.download'];
    
    const scanDirectory = (dir) => {
      try {
        if (!fs.existsSync(dir)) return;
        
        const items = fs.readdirSync(dir, { withFileTypes: true });
        
        items.forEach(item => {
          const fullPath = path.join(dir, item.name);
          
          if (item.isDirectory()) {
            // Skip certain directories
            if (item.name === 'thumbnails' || item.name === 'trash' || item.name === 'ambience') {
              return;
            }
            scanDirectory(fullPath);
          } else if (item.isFile()) {
            const ext = path.extname(item.name).toLowerCase();
            if (tempExtensions.includes(ext)) {
              try {
                fs.unlinkSync(fullPath);
              } catch (e) {
                // Ignore
              }
            }
            // Delete fragment files
            if (/\.f\d+$/.test(item.name) || /\.frag-\d+$/.test(item.name)) {
              try {
                fs.unlinkSync(fullPath);
              } catch (e) {
                // Ignore
              }
            }
          }
        });
      } catch (err) {
        // Ignore errors
      }
    };

    scanDirectory(publicDir);
    console.log('Cleaned up all temporary files in public directory');
  }

  /**
   * Clean up orphaned thumbnails that don't have corresponding video files
   */
  cleanupOrphanedThumbnails() {
    const thumbnailsDir = path.join(__dirname, '../public/thumbnails');
    const publicDir = path.join(__dirname, '../public');
    
    if (!fs.existsSync(thumbnailsDir)) return;
    
    // Get all video files in public directory to match against
    const videoExtensions = ['.mp4', '.webm', '.mkv', '.m4a', '.mp3', '.mov', '.avi', '.flv', '.wmv'];
    const videoFiles = new Set();
    
    const scanForVideos = (dir) => {
      try {
        if (!fs.existsSync(dir)) return;
        
        const items = fs.readdirSync(dir, { withFileTypes: true });
        
        items.forEach(item => {
          const fullPath = path.join(dir, item.name);
          
          if (item.isDirectory()) {
            if (item.name === 'thumbnails' || item.name === 'trash' || item.name === 'ambience') {
              return;
            }
            scanForVideos(fullPath);
          } else if (item.isFile()) {
            const ext = path.extname(item.name).toLowerCase();
            if (videoExtensions.includes(ext)) {
              const baseName = item.name.replace(/\.[^/.]+$/, '');
              videoFiles.add(baseName);
            }
          }
        });
      } catch (err) {
        // Ignore
      }
    };
    
    scanForVideos(publicDir);
    
    // Now scan thumbnails directory and delete thumbnails without matching videos
    const thumbnailExtensions = ['.jpg', '.webp', '.png', '.gif', '.jpeg'];
    let deletedCount = 0;
    
    const scanThumbnails = (dir) => {
      try {
        if (!fs.existsSync(dir)) return;
        
        const items = fs.readdirSync(dir, { withFileTypes: true });
        
        items.forEach(item => {
          const fullPath = path.join(dir, item.name);
          
          if (item.isDirectory()) {
            scanThumbnails(fullPath);
          } else if (item.isFile()) {
            const ext = path.extname(item.name).toLowerCase();
            if (thumbnailExtensions.includes(ext)) {
              const baseName = item.name.replace(/\.[^/.]+$/, '');
              const hasVideo = videoFiles.has(baseName) || 
                               videoFiles.has(baseName.replace(/\s+\d+$/, ''));
              
              if (!hasVideo) {
                try {
                  fs.unlinkSync(fullPath);
                  deletedCount++;
                } catch (e) {
                  // Ignore
                }
              }
            }
          }
        });
      } catch (err) {
        // Ignore
      }
    };
    
    scanThumbnails(thumbnailsDir);
    
    if (deletedCount > 0) {
      console.log(`Cleaned up ${deletedCount} orphaned thumbnails`);
    }
  }

  /**
   * Manual cleanup endpoint
   */
  cleanupOrphanedFiles() {
    this.cleanupAllTempFilesInPublicDir();
    this.cleanupOrphanedThumbnails();
    
    return { success: true, message: 'Cleanup completed successfully' };
  }

  completeDownload(downloadId, success, error = null) {
    const processData = this.processes.get(downloadId);
    
    if (processData && processData.cancelled) {
      return;
    }

    if (!processData) {
      const download = this.downloads.get(downloadId);
      if (download && download.status === 'cancelled') {
        return;
      }
    }

    if (success) {
      this.updateProgress(downloadId, {
        status: 'finished',
        progress: 100
      });
    } else if (!processData?.cancelled) {
      this.updateProgress(downloadId, {
        status: 'error',
        error: error || 'Unknown error'
      });
    }

    this.processes.delete(downloadId);
  }
}

module.exports = new DownloadManager();
